intro.txt

Java Full Stack
A full-stack developer is a person who can develop application's backend and frontend. Java full-stack is basically a term used for a web developer that uses Java to develop the entire technology stack is referred to as Java full stack developer.


A developer should have the following skills to become a Java full-stack developer:

1. Import projects and files
The developer should know about installing IDE's in the system such as IntelliJ and Eclipse, hello world program in IntelliJ, how we can import project files, how we can import eclipse(Java IDE) projects in IntelliJ. These are a very basic concept which not only an experience but also a fresher candidate should have.

2. Decision making under Java
The developer should have knowledge of decision-making statements and the operators which are used to make a decision. Operators such as arithmetic operators, assignments operators, and ternary operators are used for decision making. If, else if, and else statements play an important role in decision making. So, a developer should have knowledge of all the decision-making statements and operators.

3. Flow Control
After decision-making, the developer should know control flow statements and looping statements such as while, do-while, for, switch case, break, continue, modulo operator and nested loop, etc. A developer cannot write a code if he/she has no knowledge of flow control. For a full-stack position, firstly, you should have to gain knowledge of all the basic concepts of Java because you can't develop lengthy codes for an organization if your basics are not clear of Java.

4. Methods
The developer should have knowledge of parameterized and non-parameterized methods with the return type. Method overloading and method overriding are the two most important concepts of polymorphism, which play an important role in developing Java web and desktop applications. Java is an object-oriented programming language, so your concepts of methods should be crystal and clear. The developer should also have good knowledge of code block, indentation, and statements.


5. Oops Concepts
The developer should have knowledge of all the Opps concepts because Java is completely based on objects, methods, and classes. Before diving into advanced Java, you should have to clear the concepts of core Java such as Classes, Getters, Setters, Constructors, Inheritance, Composition, Encapsulation, Abstraction, Objects, and Polymorphism, etc.





6. Core Concepts
The Oops concepts are the building blocks for every object-oriented programming language. The core concepts include Interfaces, Abstract class, multiple inheritances using interface, Inner class, Nested class, Local inner class, Anonymous object, Anonymous inner class, User input, Static elements, Static inner class, Final keyword, Packages, Scope, Access modifier, Exception handling, multiple try-catch blocks, Finally, block, Throw and throws, User-defined exception, Checked and unchecked exception, Enum, and Strings(String literals, String Object, String methods, String formatting), etc. If you have no knowledge of the core concepts of Java, get knowledge of all the above-mentioned concepts deeply.



7. Java Array
We can include Java array in core concepts, but it will be good to separate it from core concepts. The array is one of the big concepts in itself because we can perform several operations in it. We should know initializing and defining arrays, ways to define or initialize an array, perform iteration on it using for loop, access and remove variables from it, call by value and call by reference methods, and many more.



8. Collection Framework
All the above-discussed concepts are part of the core Java. Once you get knowledge of the entire core Java concepts, you are ready to dive into advanced Java and get knowledge of its concepts. The collection Framework is the 1st most important framework that provides several useful classes such as ArrayList, Stack, LinkedList, Iterators, Comparable interface, etc. We should have the implementation knowledge of all these classes and interfaces along with their methods.

The collection framework also provides some complex classes such as Set, Queue, Dequeue, Map, and TreeMap. For building complex logic and codes, these classes are very helpful to maintain data. Along with these classes, the developer should also have knowledge of different types of Sets, Custom sorting using a comparator, Equal and hashcode methods, and Searching under Maps


9. Generics
A developer should have knowledge of Generics in Java along with type parameters, generic method, bo
In Java, concurrency control and multi-threading concurrency are the two most important topics of advanced Java. The developer should have knowledge of multi-threading, how to create a thread by extending the thread class or implementing the runnable interface, Synchronization under concurrency control, Synchronized method, Synchronized block, Synchronized block on the object, Static Synchronization, Volatile keyword, Wait and notify, Interrupt, join, thread pools, CountDownLatch, Blocking queue, Reentrant lock, and Deadlock, etc. These concepts are required for writing logic or developing multi-threading applications in Java.

11. Lambda Expression
Lambda Expression was added in Java SE 8 to represent one method interface using an expression. The developer should also have knowledge of predicates and lambda expressions with methods and iterators. Lambda expression:

Very useful in the collection library.
Helps to iterate data from the collection.
Helps to filter and extract data from the collection.
Provides the implementation of an interface that has a functional interface.
Saves a lot of code.



12. Find Handling
File handling is a concept that is important for each and every programming. In order to work with files, the developer should have knowledge of all the concepts related to read and write into the files. The developer should be experienced in Data streams, Creating files on disk, Creating a directory, writing onto files, Reading files with buffer, Reading files with a scanner, Scanner v/s a Buffered reader, File deletion, Try with resources and Serialization of Objects.

All the concepts which we mentioned above are required to develop applications that work with files. So, for a Java full-stack developer position, you should have experienced in these concepts




13. Debugging
Debugging is a process or steps to find bugs and errors in the code. Debugging plays an important role in improving code quality. Developers should have the quality to debug their code. Debugging is helpful not only for debugging the code but also for understanding the flow of program code. The developer should have knowledge of how the value is updated at runtime, what is watch and how we can apply watch on variables.




14. GIT basics
GIT is one of the most widely used modern version control systems. It is an open-source project developed by Linus Torvalds in 2005. Java developers are user GIT for keeping any set of projects using a version control system. To become a Java full-stack developer, the developer should have knowledge of the following:

Features of GIT.
Setting up GIT.
Clone and import GIT project into eclipse.
Clone GIT project directly from eclipse.



15. JSP and Servlets
JSP and Servlets is a complete tutorial in itself. A developer should have knowledge of the following concepts:

Java Full Stack
a) JSP & Servlets basics

It includes concepts Servlets life cycle, JSP expressions element, JSP scriptlets element, JSP declarations element, JSP comment element, JSP directive element, Deployment descriptor, and annotations, JSP configuration in the deployment descriptor, Reading URL parameters, Include files in JSP page, Import class into JSP page, Forward and redirect under JSP, MVC overview, basic redirection using servlet and application based on MVC.

b) JSP & Servlets: Forms

The developer should have knowledge of creating forms using JSP and servlets, form elements, forms under JSP and Servlet, and form validation, etc. These concepts are required to design forms using Java. Each and every application needs to have an authentication page such as login or signup for security reasons. So, we cannot think of designing or developing an application without creating a form.

c) JSP & Servlets: Java Beans and Session management

Java Beans and Session management are both required to develop an application. Basically, a bean is a reusable software component that encapsulates many objects into a single object so that we can access it from multiple places. Session management is essential for Java web applications to manage user sessions by using several ways such as Cookies and HttpSession etc.

Bean scope, session, page & application, request scope, Beans with web forms, Session under JSP, Read & write operation of the cookie, user logout, Organizing application, Fixing redirect and forward links, handling session without a cookie, and servlet filters are the necessary topic whose knowledge is required to become a Java full stack developer.

d) JSP & Servlets: JSTL tags

JSTL tags are categorized into 5 parts, i.e., JSTL core tags, JSTL functions tags, JSTL XML tags, JSTL formatting tags and JSTL custom tag. JSTL core tags include concepts JSTL setup, JSTL set and remove tags, Reading from Bean using expression language, decision making under JSTL, JSTL choose and when tags, JSTL for loop, JSTL forEach loop, JSTL for Tokens tag, JSTL import and param tag, JSTL URL and redirect tag, and JSTL catch tag.

JSTL functions tags include JSTL length functions, JSTL trim and escapeXml function, JSTL more function, JSTL even more function and JSTL split and join function.

JSTL XML tags include JSTL XML and Parse and Out tag, JSTL XML ForEach and if tag, and JSTL XML Choose When otherwise.

JSTL formatting tags include formatting date and number(Document).

JSTL custom tag is a tag creating by the developer.

e) JSP & Servlets: Integrate web template

It is another important concept of JSP and Servlet. Many times, we need to integrate web templates into our application. In order to integrate web templates, we should have knowledge of how we can extract header and footer from the template, how to integrate the template with the project, and integrate the template with the project using JSTL.

f) JSP & Servlets: Remaining concepts

A developer should also have knowledge of how we can interact with the database, how to use the workbench, setup of the JNDI, how we can listing data on the webpage, how to use of include directive, how to add, update, delete and fetch record from the database, adding JSTL support, and Image/File upload, etc.


\16. Hibernate
Hibernate is another concept of Java. A developer should be familiar with the Hibernate and its architecture and should also have implementation knowledge of it. The developer should be experienced in MySQL and SQL workbench. In hibernate, the developer should have familiar with Session factory and session, Adding Entity class, Hibernate in Action, CRUD-Retrieving Record from Database, CRUD-Updating a Record in Database, CRUD-Deleting Record from the database, HQL(Hibernate Query Language), HQL Where clause, Update record using HQL, Deleting record using HQL, integrate hibernate with JSP and Servlet, hibernate configuration, Hibernate entity class with JSP and Servlet, Hibernate in action with JSP and Servlet, display image files, improve the view of the page, adding update information form, implement update information functionality, update specific column data using hibernate, add view image action, implement view image page, and add delete image action. All the above-mentioned concepts are related to hibernate, and hibernate is the framework that is very important for Java full-stack developers.


17. Spring framework
Spring is a framework that is mostly used for Java. It provides a comprehensive programming and configuration model for modern Java-based enterprise applications. In order to work with the Spring framework, we should have knowledge of the required software, Inversion of control, Dependency injection, Autowire scenarios, Qualifier annotation, Spring Bean, Constructor injection, Spring project on IntelliJ, Adding SpringMVC support on Eclipse, Simple dynamic web project, Model in a web project, Spring MVC minimal setup, Basic form with Spring MVC, ModelAndView and foreach on data, Springform elements such as Input and Radio, Radio-buttons and background, Dropdown list, Text area, checkbox, etc., Adding STS 3 support into Eclipse, Add external resource, add style sheet, Form validation, Database connectivity using JDBC(XML configuration and Annotation), Exception handling under Spring MVC, Restful API web service, database connectivity with hibernate, JAX-RS, Spring MVC + Restful web service background, building restful microservice with spring boot, and restful micro-service with database connectivity.

All the above concepts are required to become a full-stack Java developer. If you have knowledge of all these concepts, you will definitely crack the interview process of a Java full-stack developer.


Who is Java Developer?
A Java Developer is a specialized programmer who work on business applications, software, and websites along with software engineers and web developers. Java developer can work in following two domains:

Software/Backend development: As a software developer or backend developer, the Java developer has to perform requirement gathering, designing, database connectivity etc.
Mobile App development: A Java developer working in mobile app development domain operate on technologies such as Android development with Kotlin/Java.

Technical Skills required For Java Developer
Hands-on practice in Core Java Programming
Strong knowledge of object-oriented programming concepts, exception handling, and memory management
Must know concepts of multi-threading and dependency injection
Knowledge of HTML, XML, JSON, CSS, JavaScript, JSP, and Servlet
Good knowledge of relational and/or non-relational databases such as MySQL, MongoDB, etc.
Ability to work with ORM frameworks and technologies for example, JPA2 and Hibernate
Work experience in any Java IDE tool such as Eclipse, Intellij IDE
Experience in one of the framework - Spring, Struts, JSF
Knowledge of build tools such as Maven, Gradle, etc.
Version control (Git repository)
Awareness of CI/CD and DevOps and tools like Jenkins, GitHub pipelines, etc.



Other Preferred Skills
Experience in developing SaaS, PaaS, and cloud-based web applications
Knowledge of design principles and fundamentals of the software development lifecycle
Familiar with Java libraries and integration of front-end with back-end
Experience of the quality standards and best code practices
Basic knowledge of domains and business processes
Familiar with agile and DevOps methodologies
Logical thinking, good analytical skills, and a problem-solving attitude
Ability to multitask and manage projects with priorities
Result-oriented, growth, and constant learning mindset
Good team player and guide team members whenever required
Excellent interpersonal skills, good verbal and written communication skills
Must be updated with latest technologies and trends
Analyze and create implementation strategies and improvement plans
Contribute to the organizational processes to increase productivity
Strong debugging skills and experience in test-driven development
Good knowledge of testing and continuous deployment environment
Passionate about delivering quality code within the timeline
Hands-on experience in cloud application development and deployment
Collaborate with the team and share improvement ideas, policies, and opportunities to increase the overall experience
Experience in Agile development and tools like SCRUM, KANBAN, etc.
The above list contains several soft skills that are not tied to a specific job role. A job description of a Java developer requires specific tools and frameworks as a part of the requirement.


Salary of a Java Developer
Working as a Java developer is one of the highest-paying and rewarding job worldwide. In India, the average base salary of a Java developer is mentioned below.

Level	Experience (in Years)	Salary in India (Rs.)	Salary in US ($)
Fresher	>1 Year	293,272	
Early Career	1-4 Years	426,176	
Mid-Career	5-9 Years	872,366	
Experienced	< 10 Years	1,396,371

\

Roles and Responsibilities of a Java Developer
The roles and responsibilities of a Java developer/engineer will vary greatly depending on the company and specific position. Here are some typical responsibilities:

Backward Skip 10s

Play Video

Forward Skip 10s


Designing, implementing, and maintaining Java applications that are often high-volume and low-latency, required for mission-critical systems
Delivering high availability and performance
Contributing in all phases of the development lifecycle
Writing well-designed, efficient, and testable code
Conducting software analysis, programming, testing, and debugging
Managing Java and Java EE application development
Ensuring designs comply with specifications
Preparing and producing releases of software components
Transforming requirements into stipulations
Support continuous improvement
Investigating alternatives and technologies
Presenting for architectural review


Thread States in Java
A thread is a program in execution created to perform a specific task. Life cycle of a Java thread starts with its birth and ends on its death.

The start() method of the Thread class is used to initiate the execution of a thread and it goes into runnable state and the sleep() and wait() methods of the Thread class sends the thread into non runnable state.

After non runnable state, thread again comes into runnable state and starts its execution. The run() method of thread is very much important. After executing the run() method, the lifecycle of thread is completed.

All these phases of threads are the states of thread in Java.
Play

Next
Unmute
Current TimeÂ 
0:00
/
DurationÂ 
18:10
Â 
Fullscreen

Backward Skip 10s

Play Video

Forward Skip 10s

To work with threads in a program, it is important to identify thread state. The following figure shows thread states in Java thread life cycle.




Thread States in Java
A thread is a path of execution in a program that goes through the following states of a thread. The five states are as follows:

New
Runnable
Running
Blocked (Non-runnable state)


New (Newborn State)
When an instance of the Thread class is created a new thread is born and is known to be in New-born state. That is, when a thread is born, it enters into new state but its execution phase has not been started yet on the instance.

In simpler terms, Thread object is created but it cannot execute any program statement because it is not in an execution state of the thread. Only start() method can be called on a new thread; otherwise, an IllegalThreadStateException will be thrown.


Runnable State
The second phase of a new-born thread is the execution phase. When the start() method is called on a the new instance of a thread, it enters into a runnable state.
In the runnable state, thread is ready for execution and is waiting for availability of the processor (CPU time). There are many threads that are ready for execution, they all are waiting in a queue (line).

If all threads have equal priority, a time slot is assigned for each thread execution on the basis of first-come, first-serve manner by CPU. The process of allocating time to threads is known as time slicing. A thread can come into runnable state from running, waiting, or new states.


Running State
Running means Processor (CPU) has allocated time slot to thread for its execution. When thread scheduler selects a thread from the runnable state for execution, it goes into running state. Look at the above figure.

In running state, processor gives its time to the thread for execution and executes its run method. It is the state where thread performs its actual functions. A thread can come into running state only from runnable state.



A running thread may give up its control in any one of the following situations and can enter into the blocked state.

When sleep() method is invoked on a thread to sleep for specified time period, the thread is out of queue during this time period. The thread again reenters into the runnable state as soon as this time period is elapsed.
When a thread is suspended using suspend() method for some time in order to satisfy some conditions. A suspended thread can be revived by using resume() method.
When wait() method is called on a thread to wait for some time. The thread in wait state can be run again using notify() or notifyAll() method.






Blocked State
A thread is considered to be in the blocked state when it is suspended, sleeping, or waiting for some time in order to satisfy some condition.

Dead State
A thread dies or moves into dead state automatically when its run() method completes the execution of statements. That is, a thread is terminated or dead when a thread comes out of run() method. A thread can also be dead when the stop() method is called.

During the life cycle of thread in Java, a thread moves from one state to another state in a variety of ways. This is because in multithreading environment, when multiple threads are executing, only one thread can use CPU at a time.

All other threads live in some other states, either waiting for their turn on CPU or waiting for satisfying some conditions. Therefore, a thread is always in any of the five states.





Java Thread Program
ThreadDemo.java

/* Thread 1 */  
class Thread1 extends Thread   
{  
      
    public void run()   
    {  
        System.out.println("Thread 1");  
        System.out.println("i in Thread 1 ");  
        for (int i = 1; i <= 5; i++)   
        {  
            System.out.println("i = " + i);  
            try   
            {  
                Thread.sleep(1000);  
            }   
            catch (InterruptedException e)   
            {  
                e.printStackTrace();  
            }  
        }  
        System.out.println("Thread 1 Completed.");  
    }  
}  
  
/* Thread 2 */  
class Thread2 extends Thread   
{  
    public void run()   
    {  
        System.out.println("Thread 2");  
        System.out.println("i in Thread 2 ");  
        for (int i = 1; i <= 5; i++)  
        {  
            System.out.println("i = " + i);  
        }  
        System.out.println("Thread 2 Completed.");  
    }  
}  
  
/* Driver code */  
public class ThreadDemo   
{  
    public static void main(String[] args) {  
    // life cycle of Thread  
    // Thread's New State  
    Thread1 t1 = new Thread1();  
    Thread2 t2 = new Thread2();  
    // Both the above threads are in runnable state  
    // Running state of Thread1 and Thread2  
    t1.start();  
    // Move control to another thread  
    t2.yield();  
    // Blocked State Thread1  
    try   
    {  
        t1.sleep(1000);  
    }   
    catch (InterruptedException e)   
    {  
        e.printStackTrace();  
    }  
    t2.start();  
    System.out.println("Main Thread End");  
 }  
}  
Output:

Thread 1
i in Thread 1 
i = 1
Main Thread End
Thread 2
i in Thread 2 
i = 1
i = 2
i = 3
i = 4
i = 5
Thread 2 Completed.
i = 2
i = 3
i = 4
i = 5
Thread 1 Completed.
In the above program, Java threads are implemented by creating instances of Thread class, t1 and t2. Different methods such as start(), yield(), run(), sleep() of Thread class are implemented




Java EE v/s Node.js
Java EE stands for Java Enterprise Edition, which is currently referred to as Jakarta EE. In the past decade, it is referred to as J2EE. Java EE provides the platform to the Java developer with enterprise features like web service and distributed computing.

In order to develop server-side and network applications, the developer uses Node.js, which is an open-source and cross-platform runtime environment. Node.js is basically a combination of Runtime Environment and JavaScript Library.

Java EE v/s Node.js
Java EE comes in the category of languages, while Node.js comes in the category of frameworks. It is very complicated to choose one from Java EE and Node.js for enterprise web applications development. We recommended you break down requirements as per the business and technical needs of the application and choose one which is suitable for the requirements.

Let's try to differentiate Java EE and Node.js based on some factors:




S.N.	Factor	Java EE	Node.js
1.	APIs	For organizing and specifying the overall interaction between components, Java EE provides a set of APIs.	APIs play an important role in implementing coding consistency. APIs also help the developer to facilitate performance and maintenance.
2.	Design Patterns In Java EE, the design patterns provide solutions for improving the code quality and effectiveness of the architecture.	The design patterns provide a rich set of features that enable high performance and reliability of the enterprise web application.
3.	Modules	Java EE provides a rich set of modules through which the development process is a very flexible, adaptable, and time-efficient solution.	In addition to JavaScript library functions, there are a set of built-in modules such as HTTP. The HTTP module allows us to transfer data from one port to another port by establishing it as a connection.
4.	Scalability	Java EE doesn't wait to complete the execution of the requests as it executes requests asynchronously. It allows the application to perform the task with a number of servers, and it might decrease the performance speed.	Node.js has great horizontal scalability with the capability of adding more hardware.
5.	Speed	In comparison to node.js, Java EE takes a longer time. It process input and output request in both the blocking and non-blocking manners.	The speed of the node.js web application is high as it process input and output requests in a non-blocking manner.
6.	Security	In comparison to node.js, it has very low security.	High security for enterprise web application development.
7.	Maintainability	Java EE is known for its great code maintainability and computation efficiency.	The main advantage of Java EE is fast development. The developer can use JavaScript on both server and client sides.
8.	Development Process	Lengthy and relatively slower.	Fast and less complicated.
9.	Number of enterprises applying	106,353	49,383
10.	Use cases	TripAdvisor, GameDuell, Rezdy.	Uber, Netflix, eBay, Reddit.
11.	Supported by	Oracle and the eclipse foundation.	Community and the Node.js foundation.
The table which we defined above shows the main differences between Java EE and Node.js.







Java Image
Image class in Java is an abstract superclass for all the other classes used for graphical image representation.

Class Declaration
The declaration for java.awt.Image class is as following:

Public abstract class Image extends Object  
Java Image Class Fields
Following table shows various fields of Image class.

Field	Description
protected float accelerationPriority	It prioritise for accelerating the image.
static int SCALE_AREA_AVERAGING	It uses the area averaging image scaling algorithm.
static int SCALE_DEFAULT	It use the default image-scaling algorithm.
static int SCALE_FAST	It chooses an image-scaling algorithm that gives higher priority to scaling speed than smoothness of the scaled image.
static int SCALE_REPLICATE	It uses the image scaling algorithm embodied in the ReplicateScaleFilterClass.
static int SCALE_SMOOTH	It chooses an image-scaling algorithm that gives higher priority to image smoothness than scaling speed.
static Object UnderfinedProperty	The UndefinedProperty object should be returned whenever a property that was not defined for a particular image is fetched.
Image Class Methods
Method	Description
void flush()	It flushes all reconstructable resources being used by this image object.
float getAccelerationPriority()	It returns the current value of the acceleration priority hint.
ImageCapabilities getCapabilities(GraphicsConfiguration gc)	It returns an ImageCapabilities object which can be inquired as to the capabilities of this image on the specified GraphicsConfiguration.
abstract Graphics getGraphics()	It creates a graphics context for drawing to an offscreen image.
abstract int getHeight(ImageObserver observer)	It determines the height of the image.
abstract Object getProperty(String name, ImageObserver observer)	It gets a property of the image by name.
Image getScaledInstance(int width, int height, int hints)	It creates a scaled version of the image.
abstract ImageProducer getSource()	It gets the object that produces the pixels for the image.
abstract int getWidth(ImageObserver observer)	It determines the width of the image.
void setAccelerationPriority(float priority)	It sets a hint for the image about how important acceleration is.
Java Image Example
The following program demonstrates the use of Image class in Java.
Play

Next
Unmute
Current TimeÂ 
0:00
/
DurationÂ 
18:10
Â 
Fullscreen

Backward Skip 10s

Play Video

Forward Skip 10s

JavaImageDemo.java

import java.awt.*;  
import java.awt.event.*;  
import java.awt.image.BufferedImage;  
import java.io.*;  
import javax.imageio.ImageIO;  
public class JavaImageDemo   
{  
   /* AWT Components declaration */   
   private Frame frame1;  
   private Label label1;  
   private Label statusLabel;  
   private Panel panel1;  
   public JavaImageDemo ()  
 {  
      showFrame();  
   }  
   /* Driver Code */  
   public static void main(String[] args)  
   {  
      JavaImageDemo obj = new JavaImageDemo ();  
      obj.showImageDemo();  
   }  
   /* Method to show Frame */  
   private void showFrame()  
   {  
      frame1 = new Frame("Java AWT Examples");  
      frame1.setSize(400,400);  
      frame1.setLayout(new GridLayout(3, 1));  
      frame1.addWindowListener(new WindowAdapter()   
     {  
         public void windowClosing(WindowEvent windowEvent)  
         {  
            System.exit(0);  
         }          
      });      
      label1 = new Label();  
      label1.setAlignment(Label.CENTER);  
      statusLabel = new Label();          
      statusLabel.setAlignment(Label.CENTER);  
      statusLabel.setSize(350,100);  
      panel1 = new Panel();  
      panel1.setLayout(new FlowLayout());  
      frame1.add(label1);  
      frame1.add(panel1);  
      frame1.add(statusLabel);  
      frame1.setVisible(true);    
   }  
   /* Method to add image on the Frame */  
   private void showImageDemo()  
   {  
      label1.setText("Image class Demo");   
  
      panel1.add(new ImgComp("Desktop/sample.jfif"));  
      frame1.setVisible(true);    
   }  
   class ImgComp extends Component   
   {  
      BufferedImage ig;  
      public void paint(Graphics p)   
     {  
         p.drawImage(ig, 0, 0, null);  
      }  
      public ImgComp(String filepath)   
     {  
         try   
        {  
            ig = ImageIO.read(new File(filepath));  
         }   
         catch (IOException ex)   
        {  
            ex.printStackTrace();  
         }  
      }  
      /* Sets the size of the image */  
      public Dimension getPreferredSize()  
      {  
         if (ig == null)   
         {  
            return new Dimension(120,200);  
         }   
         else   
         {  
            return new Dimension(ig.getWidth(), ig.getHeight());  
         }  
      }  
   }  
}  
Output:

Java Image



Loose Coupling in Java
One of the most key aspects of a Java project is loose coupling. The loose coupling in Java shows how to achieve loose coupling in Java projects or programs. The more loosely coupled structures present in the project or program, the better it is. In loose coupling, a method or class is almost independent, and they have less depended on each other. In other words, the more knowledge one class or method has about another class or method, the more tightly coupled structure is developed. If the classes or methods know less about each other, the more loosely coupled structure comes into existence.





Abstraction is the Key
To achieve loose coupling, one should use abstract classes or interface while performing inheritance. The following examples will make the concept clearer.

FileName: CouplingExample.java

Backward Skip 10s

Play Video

Forward Skip 10s


// parent or base class  
class A  
{  
void foo()  
{  
  System.out.println("Inside the foo method of base class.");    
}  
}  
  
// child or derived class  
class B extends A  
{  
void foo()  
{  
  System.out.println("Inside the foo method of derived class.");    
}  
}  
  
public class CouplingExample  
{  
// main method   
public static void main(String argvs[])   
{  
  
// creating an object of class B  
B obj = new B();  
obj.foo();  
}  
}  
Output:

Inside the foo method of derived class.





Explanation: The code is simple to comprehend. There are two classes in the program. One is the base class, and another is the derived class. The derived class is being instantiated in the main method, and its foo method is invoked.

However, there is a problem in the above code. The inheritance has led to the tight coupling of classes A and B. Class B knows a lot of stuff about class A. Also, there are fair chances that changes in class A might impact class B. Let's modify the above code to understand it.

Suppose, there is a requirement to add a parameterized constructor containing two integer arguments in the base class. To incorporate the requirement, we have added a constructor in the base class.

FileName: CouplingExample1.java

// parent or base class  
class A  
{  
  
// a parameterized constructor  
A(int x, int y)  
{  
      
}  
  
void foo()  
{  
  System.out.println("Inside the foo method of base class.");    
}  
}  
  
// child or derived class  
class B extends A  
{  
void foo()  
{  
  System.out.println("Inside the foo method of derived class.");    
}  
}  
  
public class CouplingExample1  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of class B  
B obj = new B();  
obj.foo();  
}  
}  
Output:

/CouplingExample1.java:17: error: constructor A in class A cannot be applied to given types;
class B extends A
^
  required: int,int
  found: no arguments
  reason: actual and formal argument lists differ in length
1 error
Explanation: The output indicates that we have got an error in child class B. However, we did not touch anything in class B; still, we got the error. It is because of the inheritance, that leads to the tightly coupled structure. Ideally, such things should be avoided in a program or project.




Loose Coupling Code
Let's rewrite the above code using an interface.

FileName: CouplingExample2.java


interface Parent  
{  
    void foo();  
}  
  
class A implements Parent  
{  
    // parameterized constructor  
    A(int x, int y)  
    {  
          
    }  
      
    public void foo()  
    {  
        System.out.println("In the foo method of class A.");  
    }  
}  
  
class B implements Parent  
{  
    public void foo()  
    {  
        System.out.println("In the foo method of class B.");  
    }  
}  
  
public class CouplingExample2  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of class B  
B obj = new B();  
obj.foo();  
}  
}  
Output:

In the foo method of class B.


Explanation: Now, the parameterized constructor of class A is not affecting class B. It is because class A and class B both are dependent on the abstraction, which is the interface of this case. Note that not only the parameterized constructor, if any other changes are made in class A, then it will also not affect class B, and vice-versa is also true.

In the above code, class A and class B are loosely coupled as they are not directly dependent on each other. Also, whatever changes we make in class A are not visible to class B.





Benefits of loose coupling
Loose coupling allows making changes in the code easily.
Testing of loosely coupled structures is easier than the tightly coupled structure.
Less amount of code is required to make changes in a loosely coupled structure than in a tightly coupled structure.
Let's understand it with the help of an example.

FileName: CouplingExample3.java


interface Keyboard  
{  
String display();  
}  
  
class DellKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Dell keyboard.";  
return this.info;  
}  
}  
  
class LenovoKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Lenovo keyboard.";  
return this.info;  
}  
}  
  
class Computer  
{  
// the method only handles keyboard made by the company Dell  
public void keyboardUsed(DellKeyboard dk)  
{  
System.out.println("The computer is using " + dk.display());  
}  
}  
  
public class CouplingExample3  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of the class Computer  
Computer obj = new Computer();  
  
// creating an object of the class DellKeyboard  
DellKeyboard dk = new DellKeyboard();  
  
obj. keyboardUsed(dk);  
  
}  
}  
Output:

The computer is using the Dell keyboard.




Explanation: In the above code, the keyboardUsed() method is tightly coupled with the Dell keyboard. It means any other type of keyboard is not entertained by the class Computer. If we use the Lenovo keyboard, we get a compilation error.

FileName: CouplingExample4.java


interface Keyboard  
{  
String display();  
}  
  
class DellKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Dell keyboard.";  
return this.info;  
}  
}  
  
class LenovoKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Lenovo keyboard.";  
return this.info;  
}  
}  
  
class Computer  
{  
// the method only handles keyboard made by the company Dell  
public void keyboardUsed(DellKeyboard dk)  
{  
System.out.println("The computer is using " + dk.display());  
}  
}  
  
public class CouplingExample4  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of the class Computer  
Computer obj = new Computer();  
  
// creating an object of the class LenovoKeyboard  
LenovoKeyboard lk = new LenovoKeyboard();  
  
obj.keyboardUsed(lk);  
  
}  
}  
Output:

/CouplingExample3.java:50: error: incompatible types: LenovoKeyboard cannot be converted to DellKeyboard
obj.keyboardUsed(lk);



Practically speaking, a computer should work perfectly with Dell or Lenovo keyboard. However, this is not the case in our example. To make the computer work with the Lenovo keyboard, we have to add another method in the class Computer.

FileName: CouplingExample5.java

interface Keyboard  
{  
String display();  
}  
  
class DellKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Dell keyboard.";  
return this.info;  
}  
}  
  
class LenovoKeyboard implements Keyboard  
{  
  
String info;  
  
public String display()  
{  
this.info = "the Lenovo keyboard.";  
return this.info;  
}  
}  
  
class Computer  
{  
// the method only handles keyboard made by the company Dell  
public void keyboardUsed(DellKeyboard dk)  
{  
System.out.println("The computer is using " + dk.display());  
}  
  
// the method only handles keyboard made by the company Lenovo  
public void keyboardUsed(LenovoKeyboard dk)  
{  
System.out.println("The computer is using " + dk.display());  
}  
  
}  
  
public class CouplingExample5  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of the class Computer  
Computer obj = new Computer();  
  
// creating an object of the class LenovoKeyboard  
LenovoKeyboard lk = new LenovoKeyboard();  
  
obj.keyboardUsed(lk);  
  
}  
}  
Output:

The computer is using the Lenovo keyboard.





Explanation: Now, the computer works for the Lenovo keyboard. However, the keyboardUsed() method is tightly coupled with Lenovo as well as the Dell keyboard. Thus, any other variety of keyboard is not considered by the keyboardUsed() method. Hence, we ended up with the same problem. Also, it is not good to add a method for a specific keyboard in the class Computer.

Think what will happen if we have 50 varieties of keyboards? Handling 50 methods is certainly a tedious task. Also, one has to write a lot of code to add 50 methods. Also, for testing purposes, we have to test all of the added 50 methods, that will be time-consuming.

To avoid such problems, we have to make the method keyboardUsed() loosely coupled with the keyboard. To achieve the same, our keyboardUsed() method should depend upon the interface (remember! Abstraction is the key). Observe the modification done in the following code.

FileName: CouplingExample6.java

interface Keyboard  
{  
String display();  
}  
  
class DellKeyboard implements Keyboard  
{  
  
String info;  
public String display()  
{  
this.info = "the Dell keyboard.";  
return this.info;  
}  
}  
  
class LenovoKeyboard implements Keyboard  
{  
  
String info;  
public String display()  
{  
this.info = "the Lenovo keyboard.";  
return this.info;  
}  
}  
  
class Computer  
{      
// the method is now dependent on the interface Keyboard  
public void keyboardUsed(Keyboard k)  
{  
System.out.println("The computer is using " + k.display());  
}  
  
}  
  
public class CouplingExample6  
{  
  
// main method   
public static void main(String argvs[])   
{  
// creating an object of the class Computer  
Computer obj = new Computer();  
  
// creating an object of the class LenovoKeyboard  
LenovoKeyboard lk = new LenovoKeyboard();  
  
obj.keyboardUsed(lk);  
  
// creating an object of the class DellKeyboard  
DellKeyboard dk = new DellKeyboard();  
  
obj.keyboardUsed(dk);  
  
}  
}  
Output:

The computer is using the Lenovo keyboard.
The computer is using the Dell keyboard.




Explanation: We see that one method is handling keyboards manufactured by the company Dell or Lenovo. It is because the only one method keyboardUsed() of the class Computer is not tightly attached with the class DellKeyboard or LenovoKeyboard. The keyboardUsed() method is dependent on the abstraction (interface Keyboard). Therefore, the method is able to handle any kind of keyboard.

Thus, even if we add 50 more types of keyboard, the keyboardUsed() method is able to handle it. Hence, we have to write a lesser amount of code as compared to the previous code.

Testing the above code is also easier as we have only one method in the class Computer. Previously, we have to test all the methods of class Computer for every type of keyboard.

Also, if in the future the Dell company stops the manufacturing of the keyboard, then we can remove the DellKeboard class. Nothing has to be changed in the class Computer. However, in the previous example, we have to remove the method keyboardUsed(DellKeyboard dk) from the class Computer.

We can observe that if we add something or remove something, we have to make more changes in the previous code and lesser changes to the above code. Thus, it is evident that why one should strive for loosely coupled structures.


Loose Coupling in Day-to-Day Life
There are many instances in our day-to-day life where the loose coupling is used. A few of those instances are mentioned below.

Clock and its Battery: We all have clocks in our homes. The clock needs a battery to run. Note that the clock is loosely coupled with the battery used, i.e., the clock has no issue if we use a Duracell battery, or a Nippo battery, or an Eveready battery, or a battery of any other company.
Mobile and its charger: The charger of mobile is not tightly coupled with the mobile. For example, a Samsung mobile can be charged with a Redmi charger, and vice-versa.
Computer and Mouse: A computer from a vendor works well with the mouse made by some other vendor. Thus, we can say that a computer and its mouse are loosely coupled.
Bulb holder and bulb: The holder of a bulb can hold any type of bulb. It does not depend on the type of bulb used. For example, an LED or filament bulb can be put in the same bulb holder.


Java Top 10 Libraries

Backward Skip 10s

Play Video

Forward Skip 10s

Java is one of the most popular programming languages. Java provides a rich set of libraries, and its standard Java library is a very powerful that contains libraries such as java.lang, java.util, and java.math, etc. Java provides more than thousands of libraries except standard libraries. Some of the most useful and popular libraries are as follows:

Java Standard libraries
Apache Commons
Jackson
Maven
Google-json
Log5j and Slf4j
JUnit
Google Guava
JAXB
HTTP Libraries
Let's understand each of the libraries one by one:




Java Standard Library
Java Top 10 Libraries
Java Standard Library is one of the most popular and used libraries, which contains a list of libraries to make work easier. These libraries are called at run time by JVM(Java Virtual Machine). It provides the following libraries:

We cannot write any program in Java without String, Enum, Double, etc. The lang library provides everything to us for writing code in Java.
In order to use data structures and collections in Java, we need util class because it contains the definition of all data structures and collections.
In order to work with pipes and to read data from files, we need the io library. It allows developers to use files in their Java applications.
The nio is another library that stands for non-blocking I/O and is an alternative to java.io library. By using it, we can get the advantage of intensive use of I/O operations.
The math library is one of the libraries used for mathematical calculation, such as the sum of BigInteger or BigDecimal.
In order to work with networks, connections, and sockets, java.net provides all the required classes for it. The net library is mostly used for developing network applications.
The swing and java.awt are two libraries used to create GUI(Graphical User Interface). The java.awt is available in the older version of Java.
sound is another library that is used for media content.




Apache Commons
Java Top 10 Libraries
Apache Commons is another library or can say it is an open-source project which focuses on all aspects of reusable Java components. It has three parts such as Commons Proper, Commons Sandbox, and Commons Dormant.

The Commons Proper contains reusable Java components.
The Common Sandbox is basically a workspace to develop java components.
The Commons Dormant is basically a repository that contains the inactive components
The Apache Commons has the following features:

Java Classes.
Mathematics and Statistics components.
I/O utilities.
Logging utilities.
JDBC helper.
Java Collections framework extension.



Jackson Libraries
Java Top 10 Libraries
In Java, we need to work with data of different types of formats. In software development, we have to save, load, and transfer data into various formats. The JSON format is one of the formats which is mostly used in software development. Besides JSON, there are many more data formats such as CSV, XML, BSON, and Avro.

Jackson library is basically a suite of data processing libraries. The Jackson JSON library is a parser/generator library for transferring a .class file into a JSON format or JSON string. The Java Jackson library provides data binding and annotations, which can convert POJO objects into data or generate POJO from data.


Maven Libraries
Java Top 10 Libraries
Just like Apache Commons, Maven is also provided by the Apache. It is a comprehensive tool that is based on the project object model. By using Maven, we can build java web and desktop applications. Maven is a repository that manages configurations, documentation, build configuration, and dependency by specifying them in the pom.xml file.

Maven helps us to add a set of jar files in each project, create the right project structure and build and deploy the project. In order to learn more about Maven, visit https://www.javatpoint.com/maven-tutorial.




Google-json
Google-json is similar to Jackson, which is mainly used to convert Java Objects to JSON and vice versa. We need to convert the Java object into JSON and other formats when developing mobile applications and writing and using Rest APIs in Java applications.

It provides methods such as toJson() and fromJson() for converting objects into JSON and vice versa. It has extensive support of Java generics and provides custom representations for objects. We can convert the pre-existing unmodifiable objects into JSON or can form them and generate them from the JSON by using the Google-json library.





Log5j and Slf4j
Java Top 10 Libraries
Log5j is one of the light-weighted and fast logging libraries in Java. This library is available in Java5 or higher versions. Log5j is an advanced version of Log4j. In terms of style, it is similar to the Log4j, but it uses the varargs feature of Java which Log4j doesn't use. The varargs feature allows us to pass any number of arguments to any logging method





Log5j also provides methods such as debugf, errorf, fatalf, logf, and tracef, which allow dynamic formatting of logging methods. These methods are very efficient when messages are not logged.

Java Top 10 Libraries
Slf4j stands for Simple Logging Facade for Java. It works as a simple facade or abstraction for various logging frameworks, which allows the end-user to plug in the desired logging framework at deployment time. In order to migrate the Java source code with Slf4j, there are several migration tools available in the market which easily migrate our projects to use the Slf4j API.





Junit is one of the most important Java frameworks for writing unit tests. Nobody wants to write the code without producing tests. Everyone includes JUnit in their projects without starting code in Java. JUnit library allows developers to write tests for our code. It provides annotations and asserts classes for writing tests in Java.



Google Guava
Google Guava is another open-source project which Google initially developed, and many engineers from outside Google contributed. It contains all the essential collections, utilities, concurrency, string manipulation, and many more. In comparison to the Apache Commons library, it is very simple and has a very good design. Google Guava plays an important role in creating shared library and utility classes. The main features of Google Guava are I/O utilities, string utilities, hashing, the extension of the Java collection framework, and caching.




JAXB library
Java Top 10 Libraries
Just like JSON, XML is another most important data format used for storage, validation, and transportation of data. In order to work with XML data in Java8, the Java Standard library has support for XML. In Java9, the XML support is removed from the Java Standard library and moved into a new library called the JAXB library. The main features of JAXB are annotation-based Java-to-XML data binding, validation, and support for all W3C XML Schema features.





HTTP Libraries
Java Top 10 Libraries
JDK doesn't support HTTP requests. In order to implement an HTTP connection, we have to use classes available in the java.net package. Using third-party libraries such as Apache HttpClient and HttpCore is not so easy to use.

JDK 9 version provides support of HTTP 2.0. We can also use Apache libraries such as HttpClient, HttpCode, and HttpAsyncClient. We suggest all the developers to get complete knowledge of these libraries before using them in the code.





Method Hiding in Java

Backward Skip 10s

Play Video

Forward Skip 10s

In this section, we will discuss what is method hiding in Java, method hiding factors (MHF), and the differences between method hiding and method overriding. Also, implement the method hiding concept in a Java program.

To understand the method hiding concept in Java, first, we will understand the method overriding. Because the method hiding concept is very similar to the method overriding.

What is method overriding?
Method overriding means subclass had defined an instance method with the same signature and return type as the instance method in the superclass. In such a case, method of the superclass is overridden (replaced) by the subclass.



Methods in Static Context
Static methods are bonded during compile time using types of reference variables not object. We know that static methods are accessed by using the class name rather than an object. Note that the static method can be overloaded, but cannot be overridden in Java






What is method hiding?
Method hiding can be defined as, "if a subclass defines a static method with the same signature as a static method in the super class, in such a case, the method in the subclass hides the one in the superclass." The mechanism is known as method hiding. It happens because static methods are resolved at compile time




Method Hiding Factors (MHF)
The method hiding factors measure the invisibilities of methods in classes.
An attribute is called visible if it can be accessed by another class or object. An attribute should be hidden within a class. They can be kept from being accessed by other objects by being declared private.
Ideally, the method hiding factor must have a large value.
The MHF can be calculated by using the following formula:
Method Hiding in Java
Example of Method Hiding in Java
Sample.java

//parent class  
class Demo  
{  
public static void method1()  
{  
System.out.println("Method-1 of the Demo class is executed.");  
}  
public void method2()  
{  
System.out.println("Method-2 of the Demo class is executed.");  
}  
}  
//child class  
public class Sample extends Demo  
{  
public static void method1()  
{  
System.out.println("Method-1 of the Sample class is executed.");  
}  
public void method2()  
{  
System.out.println("Method-2 of the Sample class is executed.");  
}  
public static void main(String args[])  
{  
Demo d1 = new Demo();  
//d2 is reference variable of class Demo that points to object of class Sample  
Demo d2 = new Sample();  
//method calling with reference (method hiding)  
d1.method1();  
d2.method1();  
//method calling with object (method overriding)  
d1.method2();  
d2.method2();  
}  
}  
Output:

Method-1 of the Demo class is executed.
Method-1 of the Demo class is executed.
Method-2 of the Demo class is executed.
Method-2 of the Sample class is executed.
We observe that the method of the superclass is hidden by the subclass.





Method Hiding Vs. Method Overriding
Hiding a static method of a superclass looks like overriding an instance method of a superclass. The main difference can be seen at runtime in the following scenario.

When we override an instance method, we get the benefit of run-time polymorphism.
When we override a static method, we do not get the benefit of run-time polymorphism.
Method Hiding	Method Overriding
Both methods must be static.	Both methods must be non-static.
Method resolution takes care by the compiler based on the reference type.	Method resolution takes care by JVM based on runtime object.
It is considered as compile-time polymorphism or static polymorphism or early binding.	It is considered as runtime polymorphism or dynamic polymorphism or late binding.
Let's understand the method handing and overriding practically.



//parent class  
class Demo  
{  
public void method1()  
{  
//statements  
}  
}  
//child class  
class Sample extends Demo  
{  
public void method1()  
{  
//statements  
}  
}  
The above code snippet does not perform the method hiding because the methods of both the classes are non-static, hence they perform method overriding.

In the above code snippet, to achieve the method hiding, we need to make the methods static.



//parent class  
class Demo  
{  
public static void method1()  
{  
//statements  
}  
}  
//child class  
class Sample extends Demo  
{  
public static void method1()  
{  
//statements  
}  
}  
The following table describes what happens when we define a method with the same signature as in superclass.

Defining a Method with the Same Signature as a Superclass's Method
Superclass Instance Method	Superclass Static Method
Subclass Instance Method	Overrides the method	Generates a compile-time error
Subclass Static Method	Generates a compile-time error	Hides the method




Java Tuple
Play

Next
Unmute
Current TimeÂ 
0:00
/
DurationÂ 
18:10
Â 
Fullscreen

Backward Skip 10s

Play Video

Forward Skip 10s
A tuple is a data structure that can hold objects of different types. These objects are not connected to each other but have meaning when we consider them collectively. In this section, we discuss what is tuple, features, size, and operations of tuples. Also, we will discuss the tuple implementation in Java.




What is a tuple?
In general, a tuple is an ordered collection of objects. In tuple data is stored as an object in a separate byte array. It has comma-separated values enclosed in a pair of square brackets []. Tuples are immutable, unlike Lists data structure. A tuple can hold multiple tuples. It can also be considered as an anonymous object.



Features of Tuple
Tuple has the following features:

It is typesafe, iterable, immutable, and serializable.
It implements the toString(), equals(), and the hashCode()
It also implements the Comparable (Tuple implements Comparable<Tuple>)




Tuple Example
Let's consider the following example.

["Sophia", "Female", 22, "Marketing Manager"]  
The above tuple is a quartet tuple because it has four elements (objects). We observe that each object is of a different type. But when we consider it collectively, it has a specific meaning. The above tuple represents the data of an employee such as name, gender, age, and designation.

Let's see some other examples of tuples.

["Java", "Object-oriented", 14]  
["John", "Wick" 21, "USA", false, "johnwick@gmail.com"]  
[3, "Samsung", "Galaxy S2", 37000.00]  



Tuple in Java
In Java, a tuple is a generic data structure that treats each element as an object, and these objects stores in a separate byte array. In other words, we can also say that tuple is an ordered collection of objects of different types.

The functionality of a tuple can be implemented using the List and Array data structure but these data structures do not hold different types of data types by design. Hence, it is clear that heterogeneous tuple using a standard data structure (List/ Array) is not possible in Java. Since we required tuple data structure to fulfill the requirement of holding homogeneous data structure.

Note that tuple data structure is not present in Java programming, by default. But we can implement the tuple data structure by using the third-party library named javatuples.

Before moving to the implementation, first, we will download the javatuples.jar file. And add this file to the path of the project.

We can also use the following dependency in pom.xml file to implement the tuples data structure in Java.


<dependency>  
<groupId>org.javatuples</groupId>  
<artifactId>javatuples</artifactId>  
<version>1.2</version>  
</dependency>   
Let's implement a tuple and create a simple Java tuple program.




Javatuples Library
The javatuples library has the tuple classes that are corresponding to the size of a tuple. Tuples may be different in size. A tuple may hold a maximum of 10 elements. The implementation of each tuple is different. The class hierarchy is as follows.

Java.lang.Object  
  ↳ org.javatuples.Tuple  
      ↳ org.javatuples.ClassName<>  
      
      
      
      Java Tuple Class
The Tuple is an abstract base class for all the tuple classes that belongs to org.javatuples package. All the methods of the tuple class are public and final. The following table summarizes the methods of the tuple class. It implements Iterable and Serializable interfaces.




Method	Syntax	Description
contains()	public final boolean contains(java.lang.Object value)	It checks if the tuple has specific element or not.
containsAll()	public final boolean containsAll(java.util.Collection<?> collection)	It returns true if this tuple contains all of the elements of the specified collection (List/Array).
equals()	public final boolean equals(java.lang.Object obj)	Overrides the equals() method of the Object class.
getSize()	public abstract int getSize()	It returns the size of tuple.
getValue()	public final java.lang.Object getValue(int pos)	Get the value at a specific position in the tuple. This method has to return object, so using it you will lose the type-safety you get with the getValueX() methods.
hashCode()	public final int hashCode()	It returns a hash code for the string. It overrides the hashCode() method of the Object class.
indexOf()	public final int indexOf(java.lang.Object value)	It returns the index within this string of the first occurrence of the specified substring.
iterator()	public final java.util.Iterator<java.lang.Object> iterator()	It returns an iterator over the elements in this tuple in proper sequence.
lastIndexOf()	public final int lastIndexOf(java.lang.Object value)	It returns the index within this string of the last occurrence of the specified substring.
toArray()	public final java.lang.Object[] toArray()	It converts the tuple into an array.
toString()	public final java.lang.String toString()	It returns a string representation of the object. Overrides the toString() method of the Object class.
toList()	public final java.util.List<java.lang.Object> toList()	It converts the tuple into a list.




Direct Known Subclasses
Size of Tuple	Tuple Class Name	Example
One Element	Unit	Unit<1>
Two Elements	Pair	Pair<1,2>
Three Elements	Triplet	Triplet<1,2,3>
Four Elements	Quartet	Quartet<1,2,3,4>
Five Elements	Quintet	Quintet<1,2,3,4,5>
Six Elements	Sextet	Sextet<1,2,3,4,5,6>
Seven Elements	Septet	Septet<1,2,3,4,5,6,7>
Eight Elements	Octet	Octet<1,2,3,4,5,6,7,8>
Nine Elements	Ennead	Ennead<1,2,3,4,5,6,7,8,9>
Ten Elements	Decade	Decade<1,2,3,4,5,6,7,8,9,10>





Besides the above classes, there are two additional classes provided by javatuples library i.e. KeyValue<A, B> and LabelValue<A, B>. These two classes are similar to the Pair class and provide the same functionality but in different semantics.

Each tuple class implements the following three interfaces:

Iterable
Comparable
Serializable






Implementation of Tuple
The implementation of a tuple in Java is very easy. We have to create an instance of tuple class that corresponds to size.




TupleExample.java

import org.javatuples.Quartet;  
public class TupleExample   
{  
public static void main(String args[])   
{  
//create a pair tuple from the constructor  
Quartet<String, String, Integer, String> quartet = new Quartet<String, String, Integer, String >("Sophia", "Female", 22, "Marketing Manager");  
//print the tuples objects  
System.out.println("The details of the employee are: " + quartet);  
}  
}  
Output:

The details of the employee are: [Sophia, Female, 22, Marketing Manager]






Tuple Operations
The following operations can be performed on a tuple:


Creating a Tuple
Getting Values
Setting Values
Adding Elements
Iterate over Tuple
Convert Tuple to List
Searching in Tuple





Creating Tuple
There are three ways to create a tuple:

By Using the with() Method
By Using Constructor
By Using Collection
Let's see the above three ways to create a tuple.

By Using the with() Method
The javatuples library provides the with() method that creates a tuple with the specified values. The method belongs to the org.javatuples.Pair package. It is used to instantiate objects with values.

Syntax:

ClassName<type-1, type-2, type-n> object = ClassName.with(value-1, value-2, ......, value-n);  
Example:

Pair<String, Double> pair = Pair.with("iPhone 12", 112000.00);  




By Using Constructor
In this case, we create a constructor of the class, according to requirement.


Syntax:

ClassName<type-1, type-2, ……, type-n> object = new ClassName<type-1, type-2, ……, type-n> (value-1, value-2, ……., value-n);  
Example:

Quintet <Integer, String, Double, String, Integer> quintet = new Quintet< Integer, String, Double, String, Integer> (91237, "Mac Book Air", 88490.00, "8-Core CPU", 4);  
Let's create a Java program to create a tuple using constructor.

CreateTupleExample2.java

import org.javatuples.Quintet;  
class CreateTupleExample1  
{  
public static void main(String args[])  
{  
Quintet <Integer, String, Double, String, Integer> quintet = new Quintet<Integer, String, Double, String, Integer> (91237, "Mac Book Air", 88490.00, "8-Core CPU", 4);  
System.out.println(quintet);  
}  
}  
Output:





[91237, Mac Book Air, 88490.0, 8-Core CPU, 4]
By Using Collection
The javatuples library allows us to create a tuple from the collection by using the fromCollection() method. It also allows us to create a tuple from an array by using the fromArray() method. Note that the collection/ array must have the same type and values as the tuple.

The collection/array must have the same type as the Tuple and the number of values in the collection/ array must match the Tuple class.

Syntax:

ClassName <type-1, type-2, …., type-n> object = ClassName.fromCollection(list);  
ClassName <type1, type2…., type-n> object = ClassName.fromArray(array);  
Example:

Octet<String, String, String, String, String, String, String, String> p1 = Octet.fromCollection(list);  
Sextet<String, String, String,String, String, String> p2 = Sextet.fromArray(arr);  
CreateTupleExample3.java

import java.util.ArrayList;  
import java.util.List;  
import org.javatuples.Sextet;  
import org.javatuples.Octet;  
class CreateTupleExample3   
{  
public static void main(String args[])  
{  
//creating a list  
List<String> list = new ArrayList<String>();  
//adding elements to the list  
list.add("C");  
list.add("C++");  
list.add("Java");  
list.add("Python");  
list.add("Scala");  
list.add("Ruby");  
list.add("PHP");  
list.add("COBOL");  
//creating an object of Pair class and passing the list  
Octet<String, String, String, String, String, String, String, String> p1 = Octet.fromCollection(list);  
//creating an Array  
String[] arr = {"One", "Two", "Three", "Four", "Five", "Six"};  
//creating an object of the Pair class and invoking the fromArray() method   
Sextet<String, String, String, String, String, String> p2 = Sextet.fromArray(arr);  
//prints the tuple created using list  
System.out.println(p1);  
//prints the tuple using Array  
System.out.println(p2);  
}  
}  
Output:

[C, C++, Java, Python, Scala, Ruby, PHP, COBOL]
[One, Two, Three, Four, Five, Six]



[91237, Mac Book Air, 88490.0, 8-Core CPU, 4]
By Using Collection
The javatuples library allows us to create a tuple from the collection by using the fromCollection() method. It also allows us to create a tuple from an array by using the fromArray() method. Note that the collection/ array must have the same type and values as the tuple.

The collection/array must have the same type as the Tuple and the number of values in the collection/ array must match the Tuple class.

Syntax:

ClassName <type-1, type-2, …., type-n> object = ClassName.fromCollection(list);  
ClassName <type1, type2…., type-n> object = ClassName.fromArray(array);  
Example:

Octet<String, String, String, String, String, String, String, String> p1 = Octet.fromCollection(list);  
Sextet<String, String, String,String, String, String> p2 = Sextet.fromArray(arr);  
CreateTupleExample3.java

import java.util.ArrayList;  
import java.util.List;  
import org.javatuples.Sextet;  
import org.javatuples.Octet;  
class CreateTupleExample3   
{  
public static void main(String args[])  
{  
//creating a list  
List<String> list = new ArrayList<String>();  
//adding elements to the list  
list.add("C");  
list.add("C++");  
list.add("Java");  
list.add("Python");  
list.add("Scala");  
list.add("Ruby");  
list.add("PHP");  
list.add("COBOL");  
//creating an object of Pair class and passing the list  
Octet<String, String, String, String, String, String, String, String> p1 = Octet.fromCollection(list);  
//creating an Array  
String[] arr = {"One", "Two", "Three", "Four", "Five", "Six"};  
//creating an object of the Pair class and invoking the fromArray() method   
Sextet<String, String, String, String, String, String> p2 = Sextet.fromArray(arr);  
//prints the tuple created using list  
System.out.println(p1);  
//prints the tuple using Array  
System.out.println(p2);  
}  
}  
Output:

[C, C++, Java, Python, Scala, Ruby, PHP, COBOL]
[One, Two, Three, Four, Five, Six]







Get values
The javatuples library also allows us to fetch values from the tuple at the specified index by using the getValueX() method. Where X denotes the index value of the object. Indexing starts from 0.

Example:

Pair<type-1, type-2> pair = new Pair<type-1, type-2>(value-1, value-2);  
type1 val1 = pair.getValue0();  
GetValueExample.java

import org.javatuples.Pair;  
class GetTupleValue  
{  
public static void main(String args[])  
{  
//creating a tuple  
Pair<Integer, String> pair = Pair.with(12, "Andrew");  
//getting values at index 1   
System.out.println(pair.getValue1());  
}  
}  
Output:

[Andrew]
Set values
As we discussed above tuples are immutable. Hence, they cannot be modified once they are created. To overcome the problem, javatuples library provides the setValueX() method. Where X is the index value at which we want to set the specific value. The method creates a copy of the tuple with the newly added value at the specified index and returns the same tuple.

Example:

Pair<type-1, type-2> pair = new Pair<type-1, type-2>(value-1, value-2);  
type1 val1 = pair.getValue0();  
SetValueExample.java

import org.javatuples.Pair;  
class SetTupleValue   
{  
public static void main(String args[])  
{  
//creating a tuple    
Pair<Integer, Integer> p1 = Pair.with(67, 69);  
//setting tuple value at index 1  
Pair<Integer, Integer> p2 = p1.setAt1(68);  
System.out.println(p2);  
}  
}  
Output:

[67, 68]
Adding a Value
There are two ways to add values in a tuple:

At the end of the tuple
At specific Index
At the end of the Tuple
The javatuples library provides the add() method to add objects to the tuple. It adds the object at the end of the tuple and returns a new tuple by matching the number of elements.

Suppose, we have a tuple having two elements and we want to add another element to the tuple. In such a case, the Pair tuple will not support the third element. Therefore, when we add an element to a Pair tuple, it gets converted into a Triplet tuple. Let's see an example.

AddElementInTuple.java

import org.javatuples.Pair;  
import org.javatuples.Triplet;  
public class AddElementInTuple   
{  
public static void main(String args[])  
{     
Pair<String, Integer> pair = Pair.with("Jack", 46);  
Triplet<String, Integer, String> triplet = pair.add("Finance Professional");  
System.out.println(pair);  
System.out.println(triplet);  
}  
}  
Output:

[Jack, 46]
[Jack, 46, Finance Professional]
We can also add one tuple to another tuple. It increases the number of elements in the newly generated tuple. Hence, it returns the type of tuple based on the number of elements present after addition.

AddTuplesExample.java


import org.javatuples.Quartet;  
import org.javatuples.Septet;  
import org.javatuples.Triplet;  
public class AddTuplesExample   
{  
public static void main(String args[])  
{  
//creating a tuple with three elements    
Triplet<String, String, String> triplet = Triplet.with("Mango", "Grapes", "Papaya");  
//creating an object of quartet tuple and adding an elements at index-1 in triplet tuple      
Quartet<String, String, String, String> quartet = triplet.addAt1("Banana");  
//adding quartet and triplet tuple we get a septet tuple i.e. 3+4=7   
//the following statement can be written as Septet septet = quartet.add(triplet);     
Septet<String, String, String, String, String, String, String> septet = quartet.add(triplet);     
System.out.println(triplet);  
System.out.println(quartet);  
System.out.println(septet);  
}  
}  
Output:

[Mango, Grapes, Papaya]
[Mango, Banana, Grapes, Papaya]
[Mango, Banana, Grapes, Papaya, Mango, Grapes, Papaya]
At Specified Index
By default, new elements are added at the end of the tuple. But we can add elements at the specified index by using the addX() method.

AddAtIndexExample.java

import org.javatuples.Quartet;  
import org.javatuples.Triplet;  
public class AddAtIndexExample   
{  
public static void main(String args[])  
{     
//creating a tuple with three elements    
Triplet<String, String, String> triplet = Triplet.with("MCA", "M.Sc.", "MBBS");  
//creating an object of quartet tuple and adding an element at index-2 in triplet tuple   
Quartet<String, String, String, String> quartet = triplet.addAt2("M.Tech");  
System.out.println(triplet);  
System.out.println(quartet);  
}  
}  
Output:

[MCA, M.Sc., MBBS]
[MCA, M.Sc., M.Tech, MBBS]
Searching an Element
We can also search for an element that resides in the tuple. For searching javatuples library provides the contains() method of the Tuple class. It returns a Boolean value true if an element is present, else returns false. Let's see an example.

SearchingElementExample.java

import org.javatuples.Pair;  
class SearchingElementExample  
{  
public static void main(String args[])  
{  
Pair<Integer, String> pair = Pair.with(34, "Jack");  
//returns true because Jack is present in tuple  
boolean res1 = pair.contains("Jack");  
//returns false because Andrew is not present in tuple   
boolean res2 = pair.contains("Andrew");  
System.out.println(res1);  
System.out.println(res2);  
}  
}  
Output:

true
false
Convert Tuple to Collection or Array
Each tuple class has asList() and toArray() methods that returns List and Array, respectively. Let's see an example.

TupleToCollection.java

import java.util.Arrays;  
import java.util.List;  
import org.javatuples.Quartet;  
public class TupleToCollection   
{  
public static void main(String args[])  
{  
//Convert to list  
Quartet<String, Integer, String, Double> quartet = Quartet.with("Dog", 12,"German Shepherd", 23.89);  
//converts to list  
List<Object> list = quartet.toList();  
//prints list  
System.out.println(list);  
//Converts to array  
Object[] quartletArr = quartet.toArray();  
//prints array  
System.out.println(Arrays.toString(quartletArr));     
}  
}  
Output:

[Dog, 12, German Shepherd, 23.89]
[Dog, 12, German Shepherd, 23.89]
Note that tuple can contain heterogeneous types so the resulting type will be of List<Object> or Object[] accordingly.

Iteration Over Tuple
All the tuple classes implement the Iterable interface. So, we can iterate a tuple in the same way as collections or arrays.

IterateTuple.java

import org.javatuples.Quartet;  
class IterateTuple   
{  
public static void main(String args[])  
{  
//creating a quartet tuple    
Quartet<String, Double, Integer, String> quartet = Quartet.with("Dell", 5600.00, 34, "Digital Solutions");  
//iterate over tuple  
for(Object obj : quartet)   
{  
//prints elements     
System.out.println(obj);  
}  
}  
}  
Output:

Dell
5600.0
34
Digital Solutions

Tuple Vs. List/Array
Java Tuple
Tuple	List
It is a set of comma-separated values that are enclosed in parenthesis.	It is a set of comma-separated values that are enclosed in square brackets.
Parenthesis is optional.	Square brackets are mandatory.
It is immutable.	It is mutable.
It requires less memory.	It requires more memory.
It has fewer factory methods.	It has more factory methods.
It has a fixed length.	It has variable lengths.
It stores heterogeneous data.	It stores homogeneous data.
It is suitable for large amounts of data.	It is suitable for a small amount of data.
It can be stored in a list.	It can be stored inside a tuple.
It is faster in comparison to List.	It is slower in comparison to the tuple.
It is represented as t1 = (1, 2, 3, 4, 5)	It is represented as l1 = [1, 2, 3, 4, 5]





Dijkstra Algorithm Java
Play

Next
Unmute
Current TimeÂ 
0:00
/
DurationÂ 
18:10
Â 
Fullscreen

Backward Skip 10s

Play Video

Forward Skip 10s
Dijkstra algorithm is one of the prominent algorithms to find the shortest path from the source node to a destination node. It uses the greedy approach to find the shortest path. The concept of the Dijkstra algorithm is to find the shortest distance (path) starting from the source point and to ignore the longer distances while doing an update.

In this section, we will implement the Dijkstra algorithm in Java program. Also, we will discuss its usage and limitations.



Dijkstra Algorithm Steps
Step1: All nodes should be marked as unvisited.

Step2: All the nodes must be initialized with the "infinite" (a big number) distance. The starting node must be initialized with zero.

Step3: Mark starting node as the current node.

Step4: From the current node, analyze all of its neighbors that are not visited yet, and compute their distances by adding the weight of the edge, which establishes the connection between the current node and neighbor node to the current distance of the current node.

Step5: Now, compare the recently computed distance with the distance allotted to the neighboring node, and treat it as the current distance of the neighboring node,

Step6: After that, the surrounding neighbors of the current node, which has not been visited, are considered, and the current nodes are marked as visited.

Step7: When the ending node is marked as visited, then the algorithm has done its job; otherwise,

Step8: Pick the unvisited node which has been allotted the minimum distance and treat it as the new current node. After that, start again from step4.



Dijkstra Algorithm Pseudo Code
Method Dijkstra(G, s): // G is graph, s is source  
distance[s] -> 0               // Distance from the source to source is always 0  
for every vertex vx in the Graph G: // doing the initialization work  
{  
if vx ? s  
{  
// Unknown distance function from source to each node set to infinity  
distance[vx] -> infinity   
}  
add vx to Queue Q   // Initially, all the nodes are in Q  
}  
  
// The while loop  
Untill the Q is not empty:                    
{  
// During the first run, this vertex is the source or starting node  
vx = vertex in Q with the minimum distance[vx]   
delete vx from Q   
}  
// where the neighbor ux has not been deleted yet from Q.  
for each neighbor ux of vx:             
              alt = distance[vx] + length(vx, ux)  
              // A path with lesser weight (shorter path), to ux is found  
              if alt < distance[ux]:                 
                  distance[ux] = alt            // updating the distance of ux   
  
      return dist[]  
  end Method  
  
  
  
  
  Implementation of Dijkstra Algorithm
The following code implements the Dijkstra Algorithm using the diagram mentioned below.

Dijkstra Algorithm Java
FileName: DijkstraExample.java


// A Java program that finds the shortest path using Dijkstra's algorithm.  
// The program uses the adjacency matrix for the representation of a graph   
  
// import statements  
import java.util.*;  
import java.io.*;  
import java.lang.*;  
  
public class DijkstraExample   
{  
// A utility method to compute the vertex with the distance value, which is minimum  
// from the group of vertices that has not been included yet   
static final int totalVertex = 9;  
int minimumDistance(int distance[], Boolean spSet[])  
{  
// Initialize min value  
int m = Integer.MAX_VALUE, m_index = -1;  
  
for (int vx = 0; vx < totalVertex; vx++)  
{  
if (spSet[vx] == false && distance[vx] <= m)   
{  
m = distance[vx];  
m_index = vx;  
}  
}  
return m_index;  
  
}  
  
// A utility method to display the built distance array  
void printSolution(int distance[], int n)  
{  
System.out.println("The shortest Distance from source 0th node to all other nodes are: ");  
for (int j = 0; j < n; j++)  
System.out.println("To " + j + " the shortest distance is: " + distance[j]);  
}  
  
// method that does the implementation of Dijkstra's shortest path algorithm  
// for a graph that is being represented using the adjacency matrix representation  
void dijkstra(int graph[][], int s)  
{  
int distance[] = new int[totalVertex]; // The output array distance[i] holds the shortest distance from source s to j  
  
// spSet[j] will be true if vertex j is included in the shortest  
// path tree or the shortest distance from the source s to j is finalized  
Boolean spSet[] = new Boolean[totalVertex];  
  
// Initializing all of the distances as INFINITE   
// and spSet[] as false  
for (int j = 0; j < totalVertex; j++)   
{  
distance[j] = Integer.MAX_VALUE;  
spSet[j] = false;  
}  
  
// Distance from the source vertex to itself is always 0  
distance[s] = 0;  
  
// compute the shortest path for all the given vertices  
for (int cnt = 0; cnt < totalVertex - 1; cnt++)   
{  
// choose the minimum distance vertex from the set of vertices  
// not yet processed. ux is always equal to source s in the first  
// iteration.  
int ux = minimumDistance(distance, spSet);  
  
// the choosed vertex is marked as true  
// it means it is processed  
spSet[ux] = true;  
  
// Updating the distance value of the neighboring vertices   
// of the choosed vertex.  
for (int vx = 0; vx < totalVertex; vx++)  
  
// Update distance[vx] if and only if it is not in the spSet, there is an  
// edge from ux to vx, and the total weight of path from source s to  
// vx through ux is lesser than the current value of distance[vx]  
if (!spSet[vx] && graph[ux][vx] != -1 && distance[ux] != Integer.MAX_VALUE && distance[ux] + graph[ux][vx] < distance[vx])  
{  
distance[vx] = distance[ux] + graph[ux][vx];  
}  
}  
  
// display the build distance array  
printSolution(distance, totalVertex);  
}  
  
// main method  
public static void main(String argvs[])  
{  
// A 9 * 9 matrix is created.   
// arr[x][y] = - 1 means, there is no any edge that connects the nodes x and y directly  
int grph[][] = new int[][] { { -1, 3, -1, -1, -1, -1, -1, 7, -1 },  
    { 3, -1, 7, -1, -1, -1, -1, 10, 4 },  
    { -1, 7, -1, 6, -1, 2, -1, -1, 1 },  
    { -1, -1, 6, -1, 8, 13, -1, -1, 3 },  
    { -1, -1, -1, 8, -1, 9, -1, -1, -1 },  
    { -1, -1, 2, 13, 9, -1, 4, -1, 5 },  
    { -1, -1, -1, -1, -1, 4, -1, 2, 5 },  
    { 7, 10, -1, -1, -1, -1, 2, -1, 6 },  
    { -1, 4, 1, 3, -1, 5, 5, 6, -1 } };  
      
// creating an object of the class DijkstraExample  
DijkstraExample obj = new DijkstraExample();  
obj.dijkstra(grph, 0);  
}  
}  
Output:

The shortest Distance from source 0th node to all other nodes are: 
To 0 the shortest distance is: 0
To 1 the shortest distance is: 3
To 2 the shortest distance is: 8
To 3 the shortest distance is: 10
To 4 the shortest distance is: 18
To 5 the shortest distance is: 10
To 6 the shortest distance is: 9
To 7 the shortest distance is: 7
To 8 the shortest distance is: 7




The time complexity of the above code is O(V2), where V is the total number of vertices present in the graph. Such time complexity does not bother much when the graph is smaller but troubles a lot when the graph is of larger size. Therefore, we have to do the optimization to reduce this complexity. With the help of the priority queue, we can decrease the time complexity. Observe the following code that is written for the graph depicted above.

FileName: DijkstraExample1.java

// Java Program shows the implementation Dijkstra's Algorithm  
// Using the Priority Queue  
  
// import statement  
import java.util.*;  
  
// Main class DijkstraExample1  
public class DijkstraExample1  
{  
  
// Member variables of the class  
private int distance[];  
private Set<Integer> settld;  
private PriorityQueue<Node> pQue;  
  
// Total count of the vertices  
private int totalNodes;  
List<List<Node> > adjacent;  
  
// Constructor of the class  
public DijkstraExample1(int totalNodes)  
{  
  
this.totalNodes = totalNodes;  
distance = new int[totalNodes];  
settld = new HashSet<Integer>();  
pQue = new PriorityQueue<Node>(totalNodes, new Node());  
}  
  
public void dijkstra(List<List<Node> > adjacent, int s)  
{  
this.adjacent = adjacent;  
  
for (int j = 0; j < totalNodes; j++)  
{  
// initializing the distance of every node to infinity (a large number)  
distance[j] = Integer.MAX_VALUE;  
}  
  
// Adding the source node to pQue  
pQue.add(new Node(s, 0));  
  
// distance of the source is always zero  
distance[s] = 0;  
  
while (settld.size() != totalNodes)   
{  
  
// Terminating condition check when  
// the priority queue contains zero elements, return  
if (pQue.isEmpty())  
{  
return;  
}  
  
// Deleting the node that has the minimum distance from the priority queue  
int ux = pQue.remove().n;  
  
// Adding the node whose distance is   
// confirmed  
if (settld.contains(ux))  
{  
continue;  
}  
  
// We don't have to call eNeighbors(ux)  
// if ux is already present in the settled set.  
settld.add(ux);  
  
eNeighbours(ux);  
}  
}  
  
private void eNeighbours(int ux)  
{  
  
int edgeDist = -1;  
int newDist = -1;  
  
// All of the neighbors of vx  
for (int j = 0; j < adjacent.get(ux).size(); j++)   
{  
Node vx = adjacent.get(ux).get(j);  
  
// If the current node hasn't been already processed  
if (!settld.contains(vx.n))   
{  
    edgeDist = vx.price;  
    newDist = distance[ux] + edgeDist;  
  
    // If the new distance is lesser in the cost  
    if (newDist < distance[vx.n])  
    {  
        distance[vx.n] = newDist;  
    }  
  
    // Adding the current node to the priority queue pQue  
    pQue.add(new Node(vx.n, distance[vx.n]));  
}  
}  
}  
  
// Main method  
public static void main(String argvs[])  
{  
  
int totalNodes = 9;  
int s = 0;  
  
// representation of the connected edges   
// using the adjacency list   
// by declaration of the List class object  
  
// Declaring and object of the type List<Node>  
List<List<Node> > adjacent = new ArrayList<List<Node> >();  
  
// Initialize list for every node  
for (int i = 0; i < totalNodes; i++) {  
    List<Node> itm = new ArrayList<Node>();  
    adjacent.add(itm);  
}  
  
// adding the edges  
// The statement adjacent.get(0).add(new Node(1, 3)); means  
// to travel from node 0 to 1, one has to cover 3 units of distance  
// it does not mean one has to travel from 1 to 0  
// To travel from 1 to 0, we have to add the statement   
// adjacent.get(1).add(new Node(0, 3));  
// Note that the distance is the same i.e., 3 units in both the cases.  
// Similarly, we have added other edges too.  
   
adjacent.get(0).add(new Node(1, 3));  
adjacent.get(0).add(new Node(7, 7));  
adjacent.get(1).add(new Node(0, 3));  
adjacent.get(1).add(new Node(2, 7));  
adjacent.get(1).add(new Node(7, 10));  
adjacent.get(1).add(new Node(8, 4));  
adjacent.get(2).add(new Node(1, 7));  
adjacent.get(2).add(new Node(3, 6));  
adjacent.get(2).add(new Node(5, 2));  
adjacent.get(2).add(new Node(8, 1));  
adjacent.get(3).add(new Node(2, 6));  
adjacent.get(3).add(new Node(4, 8));  
adjacent.get(3).add(new Node(5, 13));  
adjacent.get(3).add(new Node(8, 3));  
adjacent.get(4).add(new Node(3, 8));  
adjacent.get(4).add(new Node(5, 9));  
adjacent.get(5).add(new Node(2, 2));  
adjacent.get(5).add(new Node(3, 13));  
adjacent.get(5).add(new Node(4, 9));  
adjacent.get(5).add(new Node(6, 4));  
adjacent.get(5).add(new Node(8, 5));  
adjacent.get(6).add(new Node(5, 4));  
adjacent.get(6).add(new Node(7, 2));  
adjacent.get(6).add(new Node(8, 5));  
adjacent.get(7).add(new Node(0, 7));  
adjacent.get(7).add(new Node(1, 10));  
adjacent.get(7).add(new Node(6, 2));  
adjacent.get(7).add(new Node(8, 6));  
adjacent.get(8).add(new Node(1, 4));  
adjacent.get(8).add(new Node(2, 1));  
adjacent.get(8).add(new Node(3, 3));  
adjacent.get(8).add(new Node(5, 5));  
adjacent.get(8).add(new Node(6, 5));  
adjacent.get(8).add(new Node(7, 6));  
  
// creating an object of the class DijkstraExample1  
DijkstraExample1 obj = new DijkstraExample1(totalNodes);  
obj.dijkstra(adjacent, s);  
  
// Printing the shortest path to all the nodes  
// from the source node  
System.out.println("The shortest path from the node :");  
  
for (int j = 0; j < obj.distance.length; j++)  
{  
    System.out.println(s + " to " + j + " is " + obj.distance[j]);  
}  
}  
}  
  
// The Node class implementing the Comparator interface  
// The object of this class represents a node of the graph  
class Node implements Comparator<Node>   
{  
  
// Member variables of the Node class  
public int n;  
public int price;  
  
// Constructors of this class  
  
// Constructor 1  
public Node()   
{  
      
}  
  
// Constructor 2  
public Node(int n, int price)  
{  
this.n = n;  
this.price = price;  
}  
  
@Override   
public int compare(Node n1, Node n2)  
{  
  
if (n1.price < n2.price)  
{  
return -1;  
}  
if (n1.price > n2.price)  
{  
return 1;  
}  
  
return 0;  
}  
}  
Output:

The shortest path from the node:
0 to 0 is 0
0 to 1 is 3
0 to 2 is 8
0 to 3 is 10
0 to 4 is 18
0 to 5 is 10
0 to 6 is 9
0 to 7 is 7
0 to 8 is 7
The time complexity of the above implementation is O(V + E*log(V)), where V is the total number of vertices, and E is the number of Edges present in the graph.







      
      
      
      










